// Property of Lucian Tranc

// When using a template ush file, we need the _{ParameterName} appendix on
// global functions and parameters, because the template can be included multiple
// times for different data interfaces in a system.

StructuredBuffer<float4> {ParameterName}_CharacterTextureUvs;
StructuredBuffer<float2> {ParameterName}_CharacterSpriteSizes;
uint {ParameterName}_NumRects;

// Additional buffers for text metrics
StructuredBuffer<uint>  {ParameterName}_TextUnicode;
StructuredBuffer<float2> {ParameterName}_CharacterPositions;
StructuredBuffer<uint>  {ParameterName}_LineStartIndices;    // First spawnable index per line (or 0 if none)
StructuredBuffer<uint>  {ParameterName}_LineCharacterCounts; // Spawnable characters per line
StructuredBuffer<uint>  {ParameterName}_WordStartIndices;    // First spawnable index per word
StructuredBuffer<uint>  {ParameterName}_WordCharacterCounts; // Spawnable characters per word
uint {ParameterName}_NumChars;                               // Total spawnable character count
uint {ParameterName}_NumLines;                               // Total lines
uint {ParameterName}_NumWords;                               // Total words
uint {ParameterName}_bFilterWhitespaceCharactersValue;       // 1 if filtering whitespace characters, 0 otherwise


void GetCharacterUV_{ParameterName}(in int In_CharacterIndex, out float Out_USize, out float Out_VSize, out float Out_UStart, out float Out_VStart)
{

	int Unicode = 0;
	Unicode = {ParameterName}_TextUnicode[In_CharacterIndex];

	if (Unicode >= 0 && Unicode < {ParameterName}_NumRects)
	{
		float4 r = {ParameterName}_CharacterTextureUvs[Unicode];
		Out_USize  = r.x;
		Out_VSize  = r.y;
		Out_UStart = r.z;
		Out_VStart = r.w;
	}
	else
	{
		Out_USize = 0.0f;
		Out_VSize = 0.0f;
		Out_UStart = 0.0f;
		Out_VStart = 0.0f;
	}
}

// Returns the character position (Position/float3) at In_CharacterIndex relative to the center of the text
// Coordinate mapping: X(forward)=0, Y(left/right)=horizontal, Z(up/down)=vertical
void GetCharacterPosition_{ParameterName}(in int In_CharacterIndex, out float3 Out_CharacterPosition)
{
	if ({ParameterName}_NumChars == 0)
	{
		Out_CharacterPosition = float3(0.0f, 0.0f, 0.0f);
		return;
	}

	int idx = In_CharacterIndex;
	idx = clamp(idx, 0, int({ParameterName}_NumChars) - 1);

	float2 p = {ParameterName}_CharacterPositions[idx];

	// see UNTTDataInterface::GetCharacterPositionVM for info on why these are flipped
	Out_CharacterPosition = float3(0.0f, -p.x, -p.y);
}

// Returns the sprite size in pixels (Width, Height) for the given character index
void GetCharacterSpriteSize_{ParameterName}(in int In_CharacterIndex, out float Out_SpriteWidth, out float Out_SpriteHeight)
{
	int Unicode = 0;
	Unicode = {ParameterName}_TextUnicode[In_CharacterIndex];

	if (Unicode >= 0 && Unicode < {ParameterName}_NumRects)
	{
		float2 s = {ParameterName}_CharacterSpriteSizes[Unicode];
		Out_SpriteWidth  = s.x;
		Out_SpriteHeight = s.y;
	}
	else
	{
		Out_SpriteWidth  = 0.0f;
		Out_SpriteHeight = 0.0f;
	}
}

// Returns the number of characters in InputText
void GetTextCharacterCount_{ParameterName}(out int Out_CharacterCount)
{
	Out_CharacterCount = int({ParameterName}_NumChars);
}

// Returns the total number of lines in InputText
void GetTextLineCount_{ParameterName}(out int Out_LineCount)
{
	Out_LineCount = int({ParameterName}_NumLines);
}

// Returns the number of characters in the specified line index
void GetLineCharacterCount_{ParameterName}(in int In_LineIndex, out int Out_LineCharacterCount)
{
	if (In_LineIndex >= 0 && In_LineIndex < int({ParameterName}_NumLines))
	{
		Out_LineCharacterCount = int({ParameterName}_LineCharacterCounts[In_LineIndex]);
	}
	else
	{
		Out_LineCharacterCount = 0;
	}
}

// Returns the total number of words in InputText
void GetTextWordCount_{ParameterName}(out int Out_WordCount)
{
	Out_WordCount = int({ParameterName}_NumWords);
}

// Returns the number of characters in the specified word index
void GetWordCharacterCount_{ParameterName}(in int In_WordIndex, out int Out_WordCharacterCount)
{
	if (In_WordIndex >= 0 && In_WordIndex < int({ParameterName}_NumWords))
	{
		Out_WordCharacterCount = int({ParameterName}_WordCharacterCounts[In_WordIndex]);
	}
	else
	{
		Out_WordCharacterCount = 0;
	}
}

// Returns the number of whitespace characters after the specified word index
void GetWordTrailingWhitespaceCount_{ParameterName}(in int In_WordIndex, out int Out_TrailingWhitespaceCount)
{
	int NumWords = int({ParameterName}_NumWords);
	
	if (In_WordIndex >= 0 && In_WordIndex < NumWords)
	{
		int StartIndex = int({ParameterName}_WordStartIndices[In_WordIndex]);
		int Count = int({ParameterName}_WordCharacterCounts[In_WordIndex]);
		int EndIndex = StartIndex + Count;
		
		int NextStartIndex = int({ParameterName}_NumChars);
		
		// If not last word
		if (In_WordIndex < NumWords - 1)
		{
			NextStartIndex = int({ParameterName}_WordStartIndices[In_WordIndex + 1]);
		}
		
		int Gap = NextStartIndex - EndIndex;
		Out_TrailingWhitespaceCount = max(0, Gap);
	}
	else
	{
		Out_TrailingWhitespaceCount = 0;
	}
}

// Returns true if this DI is filtering whitespace characters, false otherwise
void GetFilterWhitespaceCharacters_{ParameterName}(out bool Out_FilterWhitespaceCharacters)
{
	Out_FilterWhitespaceCharacters = ({ParameterName}_bFilterWhitespaceCharactersValue != 0);
}

// Returns the total number of characters between StartWordIndex and EndWordIndex (inclusive).
// When whitespace filtering is disabled, trailing whitespace after each word in the range is also included.
void GetCharacterCountInWordRange_{ParameterName}(in int In_StartWordIndex, in int In_EndWordIndex, out int Out_CharacterCountInRange)
{
	int NumWords = int({ParameterName}_NumWords);
	int TotalInRange = 0;

	if (NumWords > 0 && In_StartWordIndex >= 0 && In_StartWordIndex < NumWords)
	{
		int StartIndex = In_StartWordIndex;
		int EndIndex   = clamp(In_EndWordIndex, 0, NumWords - 1);

		if (StartIndex <= EndIndex)
		{
			for (int WordIndex = StartIndex; WordIndex <= EndIndex; ++WordIndex)
			{
				int CharCount = 0;
				GetWordCharacterCount_{ParameterName}(WordIndex, CharCount);
				TotalInRange += CharCount;

				if ({ParameterName}_bFilterWhitespaceCharactersValue == 0)
				{
					int TrailingSpace = 0;
					GetWordTrailingWhitespaceCount_{ParameterName}(WordIndex, TrailingSpace);
					TotalInRange += TrailingSpace;
				}
			}
		}
	}

	Out_CharacterCountInRange = TotalInRange;
}

// Returns the total number of characters between StartLineIndex and EndLineIndex (inclusive).
void GetCharacterCountInLineRange_{ParameterName}(in int In_StartLineIndex, in int In_EndLineIndex, out int Out_CharacterCountInLineRange)
{
	int NumLines = int({ParameterName}_NumLines);
	int TotalInRange = 0;

	if (NumLines > 0 && In_StartLineIndex >= 0 && In_StartLineIndex < NumLines)
	{
		int StartIndex = In_StartLineIndex;
		int EndIndex   = clamp(In_EndLineIndex, 0, NumLines - 1);

		if (StartIndex <= EndIndex)
		{
			for (int LineIndex = StartIndex; LineIndex <= EndIndex; ++LineIndex)
			{
				int LineCharCount = 0;
				GetLineCharacterCount_{ParameterName}(LineIndex, LineCharCount);
				TotalInRange += LineCharCount;
			}
		}
	}

	Out_CharacterCountInLineRange = TotalInRange;
}